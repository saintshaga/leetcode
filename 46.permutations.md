Given a collection of distinct integers, return all possible permutations.

Example:

Input: [1,2,3]

Output:
```
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

这边思路是没有问题，对于固定长度的数组，每次选一个数作为首选数字，循环的时候，刚开始是直接swap，这样也是能得到结果的，但是问题是顺序不对，不能按照原来的顺序了

如果一定要按照原来的顺序的话，最好是用List去递归，用array递归的时候，保持顺序这边比较麻烦，写错了一个地方

下面一题也是permutation的题目，可是要排除重复的情况，关于这种问题，首先得搞清楚要求：

1， 是否有重复数字的输入

2， 如果有重复数字的输入，他们是不是连续的

3， 输出的结果是否能包含重复的

4， 输出的结果是否有顺序要求

在做47的时候，刚开始以为重复数字一定是连续的，结果还是不对，原因是在判断跟前面一个重复的时候：
```
    	for(int i=st; i<nums.length; i++) {
        if(i != 0 && nums[i] != nums[i-1]) {
          continue;
        }
        ....
```
这边写的有问题，在判断跟前面是否重复的时候，边界情况是 i != st， 而不是0，因为这个时候数组的起始点其实是st，而不是0.

这种错误如果传入的参数是List的时候应该不会犯，因此以后permutation为了方便递归和回溯，参数使用List，不使用array
