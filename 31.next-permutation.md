**思路**

解法是：
1. 从后往前找出上升的序列，把这个序列翻转；
2. 这个序列的前一个数(如果存在的话)a，在翻转后的序列中从小到大找出第一个比a大的元素b，然后交换a和b
(这一步用的是遍历的方法找的，所以速度没有很快，如果想更快的话，这一步用二分查找会更加快。没有用二分的原因是，1已经是O(n)了，这边用logn意义也不大)

**代码**

1， 从后往前找最大的升序的时候，`i >= 1` 写成了 `i > 1`。 这边心里面想的是要遍历到0，但是没有写出来

```
    	int i = n - 1;
    	while(i >= 1 &&  nums[i-1] >= nums[i]) {
    		i--;
    	}
```

2， 在找第一个比`nums[i-1]`大的数的时候，没有注意`i=n-1`这种情况。原来写的是`swap(nums, j, i)`

```
        if(i >= 1) {
        	int j = i-1;
        	while(nums[i] <= nums[j] && i < n) {
        		i++;
        	}
        	swap(nums, j,Math.min(i,n-1));
        }
```
